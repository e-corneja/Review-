<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <title>Document</title>
  </head>
  <body>
    <div class="container">
      <article class="first">
        <details>
          <summary>Объекты и их методы</summary>
          <div class="wrapper">
            <div class="left">
              <p>
                <b>Объект</b> - это ссылочный тип данных, для хранения
                коллекций, в виде пары: ключ / значение
              </p>
              <p>В JavaScript есть несколько способов создания объектов.</p>
              <ol>
                <li>
                  Литерал объекта:
                  <pre><code>
const person = { 
  name: 'John', 
  age: 30 
};
                  </code></pre>
                </li>
                <li>
                  Создание через конструктор Object:
                  <pre><code>
const person = new Object();
person.name = 'John';
person.age = 30;
                  </code></pre>
                </li>
                <li>
                  Использование функции-конструктора:
                  <pre><code>
function Person(name, age) {
  this.name = name;
  this.age = age;
}
const person = new Person('John', 30);
                  </code></pre>
                </li>
                <li>
                  С использованием метода Object.create():
                  <pre><code>
const personPrototype = {
  greet: function() {
    console.log('Привет!');
  }
};
const person = Object.create(personPrototype);
person.name = 'John';
person.age = 30;
                  </code></pre>
                </li>
                <li>
                  С использованием классов (ES6+):
                  <pre><code>
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}
const person = new Person('John', 30);
                  </code></pre>
                </li>
              </ol>
            </div>
            <div class="right">
              <h3>Основные методы объектов</h3>
              <ul>
                <li>
                  <b>Object.keys(obj)</b>: Возвращает массив строк,
                  представляющих ключи объекта.
                  <pre><code>
const myObject = { name: 'John', age: 30 };
const keys = Object.keys(myObject);
// keys = ['name', 'age']
                  </code></pre>
                </li>
                <li>
                  <b>Object.values(obj)</b>: Возвращает массив значений объекта.
                  <pre><code>
const myObject = { name: 'John', age: 30 };
const values = Object.values(myObject);
// values = ['John', 30]
                  </code></pre>
                </li>
                <li>
                  <b>Object.entries(obj)</b>: Возвращает массив массивов,
                  представляющих пары ключ-значение объекта.
                  <pre><code>
const myObject = { name: 'John', age: 30 };
const entries = Object.entries(myObject);
// entries = [['name', 'John'], ['age', 30]]
                  </code></pre>
                </li>
                <li>
                  <b>Object.fromEntries(arr/Map)</b>: Преобразует список пар
                  ключ-значение в объект.
                  <pre><code>
const arr = [["0", "a"], ["1", "b"], ["2", "c"]];
const obj = Object.fromEntries(arr);
console.log(obj); // { 0: "a", 1: "b", 2: "c" }
                  </code></pre>
                </li>
                <li>
                  <b>Object.assign(target, source)</b>: Копирует значения из
                  одного или нескольких объектов в целевой объект.
                  <pre><code>
const obj1 = { a: 1, b: 2 };
const obj2 = { b: 3, c: 4 };
const mergedObj = Object.assign({}, obj1, obj2);
// mergedObj = { a: 1, b: 3, c: 4 }
                  </code></pre>
                </li>
                <li>
                  <b>Object.create(proto, [descriptors])</b>: Который
                  используется для создания нового объекта с указанным объектом
                  прототипа. Вторым параметром(необязательным) передаются
                  дескрипторы, которые позволяют определить дополнительные
                  свойства для нового объекта. Это объект, содержащий
                  определения свойств объекта, включая их значения,
                  настраиваемость (writable), перечисляемость (enumerable) и
                  возможность изменения (configurable).
                  <pre><code>
const protoObject = {
  greet: function() {
    console.log('Привет!');
  }
};
                    
const myObject = Object.create(protoObject, {
  name: {
    value: 'John',
    writable: true, // можно изменять значение
    enumerable: true, // будет перечислен при использовании Object.keys или цикла for...in
    configurable: true // можно удалить свойство или изменить его атрибуты
  },
  age: {
    value: 30
  }
}); myObject.greet(); // Выведет "Привет!" console.log(myObject.name); // Выведет "John"
                  </code></pre>
                </li>
              </ul>
            </div>
          </div>
        </details>
      </article>

      <article class="second-a">
        <details>
          <summary>Еще методы объектов</summary>
          <ul>
            <li>
              <b>Object.getPrototypeOf()</b> Метод Object.getPrototypeOf()
              возвращает прототип (то есть, внутреннее свойство [[Prototype]])
              указанного объекта. Object.getPrototypeOf(obj). Объект, чей
              прототип будет возвращён.
            </li>
            <li>
              <b>Object.setPrototypeOf()</b> Метод Object.setPrototypeOf()
              устанавливает прототип (то есть, внутреннее свойство
              [[Prototype]]) указанного объекта в другой объект или null.
              Object.setPrototypeOf(obj, prototype); obj - Объект, которому
              устанавливается прототип. prototype Новый прототип объекта (объект
              или null).
            </li>
            <li>
              <b>Object.defineProperty()</b> Метод Object.defineProperty()
              определяет новое или изменяет существующее свойство
              непосредственно на объекте, возвращая этот объект.
              Object.defineProperty(obj, prop, descriptor). obj - Объект, на
              котором определяется свойство. prop - Имя определяемого или
              изменяемого свойства. descriptor - Дескриптор определяемого или
              изменяемого свойства.
            </li>
          </ul>
        </details>
      </article>

      <article class="second">
        <details>
          <summary>spread/rest операторы</summary>
          <p>
            СПРЕД опреатор (...) Используется для распаковки элементов
            массива/объекта. Спред опертор распространяет элементы
            массива/объекта в месте, где ожидается несколько аргументов
            (функции) или элементов (массивы/объекты).
          </p>
          <pre><code>
const array1 = [1, 2, 3];
const array2 = [...array1, 4, 5]; // распаковка     элементов array1
console.log(array2); // [1, 2, 3, 4, 5]
          </code></pre>
          <p>Рест оператор (...):</p>
          <p>
            Оператор rest — это синтаксическая конструкция в JavaScript, которая
            позволяет собирать оставшиеся элементы массива в другой массив или
            собирать оставшиеся свойства объекта в другой объект.
          </p>
          <p>
            Он всегда идёт последним и может использоваться только раз при одной
            операции «распаковки» массива или объекта.
          </p>
          <pre><code>
function exampleRest(a, b, ...rest) {
  console.log(a); // первый аргумент
  console.log(b); // второй аргумент
  console.log(rest); // массив с оставшимися аргументами
}
          </code></pre>
        </details>
      </article>

      <article class="third">
        <details>
          <summary>Деструктуризация</summary>
          <p>
            Деструктуризация или деструктурирущее присваивание - это выражение
            которое представляет удобный способ извлекать значение из объектов
            или массивов и помещать их в отдельные переменные.
          </p>
          <p>
            Переменные записываюся в прямоуголных или фигурных скобках после
            чего пишется равно и указывается объект или массив, деструктуризация
            данных которого должна произойти.
          </p>
          <pre>
            <code class="language-javascript">
const people = ['Jack', 'Max','Leo'];
const [jack, max, leo] = people;

const person = {name: 'Jack', age: 20};
const {name, age} = person;
            </code>
          </pre>
        </details>
      </article>

      <article class="fourth">
        <details>
          <summary>Map/Set</summary>
          <p>
            <b>Map</b> - это коллекция для хранения данных любого типа в виде
            [ключ, значение]. И в отличии от объектов, в которых ключами могут
            быть только строки, в Map ключом может быть произвольное значение.
            Например число или булевое значение.
          </p>
          <p>
            <b>Основные методы для работы с коллекцией Map:</b>
          </p>
          <ul>
            <li>set(ключ, значение) — устанавливает значение;</li>
            <li>get(ключ) — возвращает значение;</li>
            <li>has(ключ) — проверяет наличие переданного ключа;</li>
            <li>values() — возвращает итератор всех значений коллекции;</li>
            <li>keys() — возвращает итератор всех ключей коллекции;</li>
            <li>entries() — возвращает итератор пар [ключ, значение];</li>
            <li>delete(ключ) — удаляет конкретное значение;</li>
            <li>clear() — полностью очищает коллекцию;</li>
            <li>forEach(колбэк) — перебирает ключи и значения коллекции.</li>
            <li>
              Содержит свойство size для получения количества значений в
              коллекции.
            </li>
          </ul>
          <pre><code>
// Создание объекта Map
const myMap = new Map([[1, "привет"], ["2", "пока"]]);
            
// Добавление элементов в Map
myMap.set('key1', 'value1');
myMap.set(42, 'value2');
const objKey = { name: 'John' };
myMap.set(objKey, 'value3');
            
// Получение значения по ключу
console.log(myMap.get('key1')); // Выведет 'value1'
console.log(myMap.get(42)); // Выведет 'value2'
console.log(myMap.get(objKey)); // Выведет 'value3'
            
// Проверка наличия ключа
console.log(myMap.has('key1')); // true
            
myMap.delete('key1'); // Удаление элемента по ключу
            
// Перебор элементов Map
myMap.forEach((value, key) стрелка {
  console.log(`${key}: ${value}`);
});
            
// Получение всех ключей и значений в виде массивов
const keysArray = Array.from(myMap.keys());
const valuesArray = Array.from(myMap.values());
          </code></pre>
          <p>
            <b>Преимущества использования Map:</b> Гибкость ключей: Можно
            использовать любые значения в качестве ключей. Порядок элементов:
            Элементы в Map хранятся в том порядке, в котором они были добавлены.
            Легкость определения размера: Метод size позволяет легко определить
            количество элементов в Map. Map часто используется, когда необходимо
            сохранять пары ключ-значение и когда требуется гибкость в выборе
            типов ключей.
          </p>
          <p>
            <b>Set</b> - коллекция для хранения уникальных значений любого типа.
            Одно и то же значение нельзя добавить в Set больше одного раза. Set
            — это неиндексированная коллекция, положить элемент в коллекцию
            можно, но достать нельзя. По элементам коллекции можно
            итерироваться.
          </p>
          <pre><code>
const set = new Set([42]);
          </code></pre>
          <p>
            <b>Основные методы для работы с коллекцией Set:</b>
          </p>
          <ul>
            <li>add() — добавить элемент.</li>
            <li>delete() — удалить элемент.</li>
            <li>has() — проверить, есть ли элемент в коллекции.</li>
            <li>values() — возвращает итератор всех значений коллекции;</li>
            <li>keys() — возвращает итератор всех значений коллекции;</li>
            <li>entries() — возвращает итератор пар [значений, значение];</li>
            <li>clear() — очистить коллекцию.</li>
            <li>
              forEach() — выполнить функцию для каждого элемента в коллекции,
              аналогично одноимённому методу массива.
            </li>
            <li>
              Содержит свойство size для получения количества элементов в
              коллекции.
            </li>
          </ul>
          <p>
            С помощью Set можно легко получить массив уникальных элементов из
            массива неуникальных с помощью конструктора и спред-синтаксиса:
          </p>
          <pre><code>
const nonUnique = [1, 2, 3, 4, 5, 4, 5, 1, 1]
const uniqueValuesArr = [...new Set(nonUnique)]
            
console.log(uniqueValuesArr) // [1, 2, 3, 4, 5]
          </code></pre>
        </details>
      </article>

      <article class="fifth">
        <details>
          <summary>Контекст вызова THIS</summary>
          <p>
            Ключевое слово this в JS - это контекст вызова или ссылка на
            значение объекта, который в данный момент вызывает функцию. This
            может принимать разные значения. Это может быть глобальный объект,
            либо объявленный, либо объект события. Т.е. this способно меняться в
            зависимости от контекста выполнения. Из-за такой неопределенности
            периодически возникает такая проблема, как потеря функцией контекста
            вызова. И чтобы это исправить можно использовать один из трех
            методов: call apply bind
          </p>
          <img src="img/mwsnap022.jpg" alt="" />
        </details>
      </article>

      <article class="sixth">
        <details>
          <summary>call/bind/apply</summary>
          <p>
            В следствие ошибки или запутанности кода может произойти ситуация,
            когда значение this функции изменяется. Это называется потеря
            контекста. Чтобы избежать такой ситуации и строго определить
            контекст вызова можно воспользоваться одним из трех методов: call
            apply bind.
          </p>
          <p>
            Каждый из методов в качестве первого аргумента принимает контекст
            вызова.
          </p>
          <p>
            Разница между call и apply в том, как передаются аргументы внутрь
            функции. В случае с call - это обычное перечисление через запятую, а
            для apply, аргументы нужно передавать через массив. call apply
            вызывают сразу, т.е. в момент когда их применяют, поэтому сразу
            можно получить результат работы функции к которой они привязываются.
          </p>
          <p>
            bind создает функцию обертку, которую можно присвоить в переменную и
            затем вызвать в любом нужном месте приложения
          </p>
          <pre>
            <code>
              function showName(firstName, secondName) {
                console.log(`${this.firstName} ${this.secondName}`);
              }

              const user = {
                firstName: 'Имя',
                secondName: 'Фамилия'
              }

              showName.call(user, 'firstName', 'secondName'); // Имя Фамилия
              showName.apply(user, ['firstName', 'secondName']); // Имя Фамилия

              const newShowName = showName.bind(user, 'firstName', 'lastName');
              newShowName();
              
            </code>
          </pre>
        </details>
      </article>

      <article class="seventh">
        <details>
          <summary>Прототипы в JS</summary>
          <p>
            Механизм прототипов в JS позволяет одним объектам наследовать
            свойства и методы других объектов.
          </p>
          <p>
            Каждый объект в JS имеет специальное свойство __proto__, которое
            указывает на его прототип.
          </p>
          <p>
            Если обращаться к свойству или методу объекта, JS сначала ищет его в
            самом объекте. Если свойство или метод не найдено, то поиск
            происходит в прототипе объекта. Если в прототипе ничего не найдено,
            - поиск продолжается в прототипе прототипа и т.д. пока метод не
            будет найден или пока не будет достигнут конец цепочки прототипов
          </p>
          <p>
            Прототип объекта может быть установлен явно с помощью свойства
            prototype функции-конструктора при создании нового объекта с помощью
            ключевого слова new. Другими словами, когда объект создается с
            помощью new, его прототип автоматически становится равным prototype
            функции-конструктора
          </p>
          <pre>
            <code class="language-javascript">
              function Person(name) {
                this.name = name;
              }

              Person.prototype.sayHello = function() {
                console.log(`Hello ${this.name}`);
              }

              let john = new Person('John');
              john.sayHello(); // Hello John

              let jane = Object.create(Person.prototype);
              jane.name = 'Jane';
              jane.sayHello(); // Hello Jane
            </code>
          </pre>
        </details>
      </article>

      <article class="eighth">
        <details>
          <summary>Классы: статические методы, геттеры, сеттеры</summary>
          <p>
            Класс - это шаблон для создания экземпляров объектов. Экземпляры
            могут иметь собственные свойства и методы. Также экземпляры
            наследуют свойства и методы прототипов
          </p>
          <p>
            Начинается с ключевого слова class, далее название в Camel case
            notation
          </p>
          <p>
            Затем метод constructor(). Переменная this в методе конструктор
            указывает на экземпляр класса. Благодаря методу конструктор у нового
            экземпляра класса устанавливаются собственные свойства и методы,
            которые мы записали в конструктор
          </p>
          <h3>Создание экземпляра класса</h3>
          <pre><code>
const variable = new Comment('Аргумент метода конструктор')
          </code></pre>
          <p>
            C помощью new вызывается функция конструктор. Такая функция вернет
            новый объект. скласс будет прототипом для такого экземпляра.
            Экземпляр будет наследовать все свойства и методы прототипа.
          </p>
          <p>
            С помощью instanceOf можно проверить принадлежит ли экземпляр классу
          </p>
          <p>Пример: <b>экземпляр instanceOf Comment // true</b></p>
          <p><b>переменная instanceOf Object</b></p>
          <p><b>hasOwnProperty - проверка на наличие собственных свойств</b></p>

          <h3>Статические методы</h3>
          <p>
            доступны, как свойства класса и не наследуются экземплярами класса
          </p>
          <p><b>static названиеМетода(параметры) {}</b></p>
          <h3>Возможности расширения других классов</h3>
          <p>
            В JavaScript есть возможность расширять другие классы с
            использованием механизма наследования. Это осуществляется с помощью
            ключевого слова extends. Когда один класс расширяет другой, он
            наследует его свойства и методы.
          </p>
          <p>
            super обеспечивает корректное наследование и позволяет дочернему
            классу использовать функциональность родительского класса.
          </p>
          <p>
            <b>super(свойство) в конструкторе:</b> Когда вы вызываете метод
            super(свойство), это вызывает конструктор родительского класса. Это
            нужно, чтобы правильно установить свойство name для дочернего
            объекта. Без вызова super, свойство this.свойство в дочерний класс
            не было бы установлено.
          </p>
          <p>
            <b>super.speak() в методе:</b>
            Если у родительского класса (Animal) есть метод speak, вы можете
            использовать super.speak() в дочернем классе (Dog), чтобы вызвать
            метод родительского класса. В данном примере метод speak
            переопределен, но если бы он не был переопределен, вызов
            super.speak() вызвал бы метод speak из класса Animal.
          </p>
          <pre><code>
// Родительский класс
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(`${this.name} издает звук`);
  }
}
class Dog extends Animal {
  constructor(name, breed) {
    // Вызов конструктора родительского класса
    super(name);
    this.breed = breed;
  }
  speak() {
    console.log(`${this.name} лает`);
  }
}
          </code></pre>
          <h3>Геттеры и сеттеры</h3>
          <p>
            Геттеры и сеттеры - это особый тип свойств, которые предоставляют
            способ для доступа и изменения значений свойств объекта. Начинаются
            с ключевых слов get() set()
          </p>
          <p>
            Геттеры используются для получения значения свойства. Сеттеры
            используются для установки значения свойства.
          </p>
          <p>
            Геттеры вызываются при обращении к свойству, а сеттеры - при
            изменении значения свойства.
          </p>
          <pre><code>class Person {
            constructor(name, age) {
              this._name = name;
              this._age = age;
            }
          
            // Геттер для свойства name
            get name() {
              console.log('Геттер вызван');
              return this._name;
            }
          
            // Сеттер для свойства name
            set name(newName) {
              console.log('Сеттер вызван');
              this._name = newName;
            }
          
            // Геттер для свойства age
            get age() {
              return this._age;
            }
          
            // Сеттер для свойства age
            set age(newAge) {
              if (newAge больше или равно 0) {
                this._age = newAge;
              } else {
                console.log('Возраст не может быть отрицательным');
              }
            }
          }
          
          // Создание экземпляра класса
          const person = new Person('John', 30);
          
          // Использование геттера и сеттера
          console.log(person.name); // Геттер вызван, Выведет "John"
          person.name = 'Bob'; // Сеттер вызван
          console.log(person.name); // Геттер вызван, Выведет "Bob"
          
          console.log(person.age); // Выведет 30
          person.age = -5; // Возраст не может быть отрицательным
          console.log(person.age); // Выведет 30 (не изменился из-за некорректного значения)
          </code></pre>
        </details>
      </article>
    </div>
  </body>
</html>
